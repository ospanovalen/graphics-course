#version 430

layout(local_size_x = 32, local_size_y = 16) in;
layout(binding = 0, rgba8) uniform image2D resultImage;
const vec2 iResolution = vec2(1280, 720);
const float iTime = 2.0f;
const float PI = 3.14159265359;
const int MAX_STEPS = 200;
const float MAX_DIST = 100.0;
const float MIN_DIST = 0.001;
const float SHADOW_SOFTNESS = 64.0;
const float SPECULAR_POWER = 32.0;
const float AMBIENT_LIGHT = 0.2;
const float BALL_RADIUS = 0.4;
const float REFLECTION_STRENGTH = 0.5;
const float BALL_SPEED = 0.7;
const float BALL_ROTATION_SPEED = 1.2;
vec3 lightPos = vec3(4.0, 6.0, 8.0);

mat3 rotateY(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    return mat3(vec3(c, 0.0, -s), vec3(0.0, 1.0, 0.0), vec3(s, 0.0, c));
}

mat3 rotateX(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, -s), vec3(0.0, s, c));
}

float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

float opSmoothUnion(float d1, float d2, float k) {
    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return mix(d2, d1, h) - k * h * (1.0 - h);
}

vec3 ballTrajectory(float time, float index) {
    float jumpHeight = abs(sin(time * BALL_SPEED + index)) * 3.0; // Мяч прыгает
    return vec3(sin(time * BALL_SPEED + index) * 4.0, jumpHeight, cos(time * BALL_SPEED + index) * 4.0);
}

float sceneSDF(vec3 p) {
    float time = iTime * BALL_ROTATION_SPEED;
    float d = MAX_DIST;

    for (int i = 0; i < 5; i++) {
        vec3 ballPos = ballTrajectory(time, float(i) * 2.0 * PI / 5.0);
        float ballDist = sdSphere(p - ballPos, BALL_RADIUS);
        d = opSmoothUnion(d, ballDist, 0.2);
    }
    
    float ground = p.y + 0.4;
    d = min(d, ground);
    
    return d;
}

vec3 getNormal(vec3 p) {
    float h = MIN_DIST;
    vec3 n = vec3(
        sceneSDF(p + vec3(h, 0, 0)) - sceneSDF(p - vec3(h, 0, 0)),
        sceneSDF(p + vec3(0, h, 0)) - sceneSDF(p - vec3(0, h, 0)),
        sceneSDF(p + vec3(0, 0, h)) - sceneSDF(p - vec3(0, 0, h))
    );
    return normalize(n);
}

vec3 rayMarch(vec3 ro, vec3 rd) {
    float t = 0.0;
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ro + rd * t;
        float dist = sceneSDF(p);
        if (dist < MIN_DIST) {
            return p;
        }
        t += dist;
        if (t > MAX_DIST) break;
    }
    return vec3(MAX_DIST);
}

float softShadow(vec3 ro, vec3 rd, float k) {
    float res = 1.0;
    float t = 0.02;
    for (int i = 0; i < MAX_STEPS; i++) {
        float h = sceneSDF(ro + rd * t);
        if (h < MIN_DIST) return 0.0;
        res = min(res, k * h / t);
        t += h;
        if (t > MAX_DIST) break;
    }
    return res;
}

vec3 phongLighting(vec3 p, vec3 normal, vec3 viewDir) {
    vec3 lightDir = normalize(lightPos - p);
    
    vec3 ambient = AMBIENT_LIGHT * vec3(0.2, 0.8, 0.2);
    
    float diff = max(dot(normal, lightDir), 0.0);
    vec3 diffuse = diff * vec3(1.0);
    
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), SPECULAR_POWER);
    vec3 specular = spec * vec3(1.0);
    
    float shadow = softShadow(p, lightDir, SHADOW_SOFTNESS);
    
    return (ambient + shadow * (diffuse + specular));
}

vec3 getCameraPosition(float time) {
    float radius = 10.0;
    float height = 4.0;
    return vec3(sin(time) * radius, height, cos(time) * radius);
}

vec3 getCameraTarget() {
    return vec3(0.0, 1.0, 0.0);
}


void main()
{
  ivec2 iuv = ivec2(gl_GlobalInvocationID.xy);
  vec2 uv = (iuv - 0.5 * iResolution.xy) / iResolution.y;  
  float time = iTime * 0.2;
  vec3 ro = getCameraPosition(time);
  vec3 lookAt = getCameraTarget();    
  vec3 forward = normalize(lookAt - ro);
  vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
  vec3 up = cross(right, forward);
  vec3 rd = normalize(forward + uv.x * right + uv.y * up);
  vec3 p = rayMarch(ro, rd);
  if (length(p) < MAX_DIST) {
      vec3 normal = getNormal(p);
      vec3 viewDir = normalize(ro - p);
      vec3 color = phongLighting(p, normal, viewDir);
      imageStore(resultImage, iuv, vec4(color, 1));
  } else { 
      imageStore(resultImage, iuv, vec4(0.2, 0.8, 0.2, 1.0));
  }
}